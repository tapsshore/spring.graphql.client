{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport { createFragmentMap, getFragmentFromSelection, getDefaultValues, getFragmentDefinitions, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField } from \"../../utilities/index.js\";\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, isArray } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n;\n\nfunction getContextFlavor(context, clientOnly, deferred) {\n  var key = \"\".concat(clientOnly).concat(deferred);\n  var flavored = context.flavors.get(key);\n\n  if (!flavored) {\n    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), {\n      clientOnly: clientOnly,\n      deferred: deferred\n    }));\n  }\n\n  return flavored;\n}\n\nvar StoreWriter = function () {\n  function StoreWriter(cache, reader) {\n    this.cache = cache;\n    this.reader = reader;\n  }\n\n  StoreWriter.prototype.writeToStore = function (store, _a) {\n    var _this = this;\n\n    var query = _a.query,\n        result = _a.result,\n        dataId = _a.dataId,\n        variables = _a.variables,\n        overwrite = _a.overwrite;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var context = {\n      store: store,\n      written: Object.create(null),\n      merge: function (existing, incoming) {\n        return merger.merge(existing, incoming);\n      },\n      variables: variables,\n      varString: canonicalStringify(variables),\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map()\n    };\n    var ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: {\n        map: new Map()\n      },\n      context: context\n    });\n\n    if (!isReference(ref)) {\n      throw __DEV__ ? new InvariantError(\"Could not identify object \".concat(JSON.stringify(result))) : new InvariantError(6);\n    }\n\n    context.incomingById.forEach(function (_a, dataId) {\n      var storeObject = _a.storeObject,\n          mergeTree = _a.mergeTree,\n          fieldNodeSet = _a.fieldNodeSet;\n      var entityRef = makeReference(dataId);\n\n      if (mergeTree && mergeTree.map.size) {\n        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n\n        if (isReference(applied)) {\n          return;\n        }\n\n        storeObject = applied;\n      }\n\n      if (__DEV__ && !context.overwrite) {\n        var fieldsWithSelectionSets_1 = Object.create(null);\n        fieldNodeSet.forEach(function (field) {\n          if (field.selectionSet) {\n            fieldsWithSelectionSets_1[field.name.value] = true;\n          }\n        });\n\n        var hasSelectionSet_1 = function (storeFieldName) {\n          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n        };\n\n        var hasMergeFunction_1 = function (storeFieldName) {\n          var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n\n        Object.keys(storeObject).forEach(function (storeFieldName) {\n          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n          }\n        });\n      }\n\n      store.merge(dataId, storeObject);\n    });\n    store.retain(ref.__ref);\n    return ref;\n  };\n\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n\n    var dataId = _a.dataId,\n        result = _a.result,\n        selectionSet = _a.selectionSet,\n        context = _a.context,\n        mergeTree = _a.mergeTree;\n    var policies = this.cache.policies;\n    var incoming = Object.create(null);\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    var readField = function () {\n      var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n\n      if (isReference(options.from)) {\n        var info = context.incomingById.get(options.from.__ref);\n\n        if (info) {\n          var result_1 = policies.readField(__assign(__assign({}, options), {\n            from: info.storeObject\n          }), context);\n\n          if (result_1 !== void 0) {\n            return result_1;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    var fieldNodeSet = new Set();\n    this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {\n      var _a;\n\n      var resultFieldKey = resultKeyNameFromField(field);\n      var value = result[resultFieldKey];\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        var storeFieldName = policies.getStoreFieldName({\n          typename: typename,\n          fieldName: field.name.value,\n          field: field,\n          variables: context.variables\n        });\n        var childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context, false, false) : context, childTree);\n\n        var childTypename = void 0;\n\n        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n          childTypename = readField(\"__typename\", incomingValue);\n        }\n\n        var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n\n        if (merge) {\n          childTree.info = {\n            field: field,\n            typename: typename,\n            merge: merge\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n      } else if (__DEV__ && !context.clientOnly && !context.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {\n        __DEV__ && invariant.error(\"Missing field '\".concat(resultKeyNameFromField(field), \"' while writing result \").concat(JSON.stringify(result, null, 2)).substring(0, 1000));\n      }\n    });\n\n    try {\n      var _b = policies.identify(result, {\n        typename: typename,\n        selectionSet: selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField: readField\n      }),\n          id = _b[0],\n          keyObject = _b[1];\n\n      dataId = dataId || id;\n\n      if (keyObject) {\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      var dataRef = makeReference(dataId);\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n        return dataRef;\n      }\n\n      var previous_1 = context.incomingById.get(dataId);\n\n      if (previous_1) {\n        previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n        fieldNodeSet.forEach(function (field) {\n          return previous_1.fieldNodeSet.add(field);\n        });\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet: fieldNodeSet\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  };\n\n  StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n    var _this = this;\n\n    if (!field.selectionSet || value === null) {\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map(function (item, i) {\n        var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      mergeTree: mergeTree\n    });\n  };\n\n  StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n    if (typename === void 0) {\n      typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);\n    }\n\n    var fieldMap = new Map();\n    var policies = this.cache.policies;\n    var limitingTrie = new Trie(false);\n\n    (function flatten(selectionSet, inheritedContext) {\n      var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n      selectionSet.selections.forEach(function (selection) {\n        if (!shouldInclude(selection, context.variables)) return;\n        var clientOnly = inheritedContext.clientOnly,\n            deferred = inheritedContext.deferred;\n\n        if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {\n          selection.directives.forEach(function (dir) {\n            var name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n\n            if (name === \"defer\") {\n              var args = argumentsObjectFromField(dir, context.variables);\n\n              if (!args || args.if !== false) {\n                deferred = true;\n              }\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          var existing = fieldMap.get(selection);\n\n          if (existing) {\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n        } else {\n          var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  };\n\n  StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n    var _a;\n\n    var _this = this;\n\n    if (mergeTree.map.size && !isReference(incoming)) {\n      var e_1 = !isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;\n      var i_1 = incoming;\n\n      if (e_1 && !getStorageArgs) {\n        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n      }\n\n      var changedFields_1;\n\n      var getValue_1 = function (from, name) {\n        return isArray(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n      };\n\n      mergeTree.map.forEach(function (childTree, storeFieldName) {\n        var eVal = getValue_1(e_1, storeFieldName);\n        var iVal = getValue_1(i_1, storeFieldName);\n        if (void 0 === iVal) return;\n\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n\n        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n\n        if (aVal !== iVal) {\n          changedFields_1 = changedFields_1 || new Map();\n          changedFields_1.set(storeFieldName, aVal);\n        }\n\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields_1) {\n        incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);\n        changedFields_1.forEach(function (value, name) {\n          incoming[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n    }\n\n    return incoming;\n  };\n\n  return StoreWriter;\n}();\n\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\n\nfunction getChildMergeTree(_a, name) {\n  var map = _a.map;\n\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || {\n      map: new Map()\n    });\n  }\n\n  return map.get(name);\n}\n\nfunction mergeMergeTrees(left, right) {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n  var needToMergeMaps = left.map.size && right.map.size;\n  var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;\n  var merged = {\n    info: info,\n    map: map\n  };\n\n  if (needToMergeMaps) {\n    var remainingRightKeys_1 = new Set(right.map.keys());\n    left.map.forEach(function (leftTree, key) {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys_1.delete(key);\n    });\n    remainingRightKeys_1.forEach(function (key) {\n      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree) {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree(_a, name) {\n  var map = _a.map;\n  var childTree = map.get(name);\n\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nvar warnings = new Set();\n\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  if (isReference(existing)) return;\n  if (equal(existing, incoming)) return;\n\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  __DEV__ && invariant.warn(\"Cache data may be lost when replacing the \".concat(fieldName, \" field of a \").concat(parentType, \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \").concat(childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\", \"define a custom merge function for the \").concat(typeDotName, \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \").concat(JSON.stringify(existing).slice(0, 1000), \"\\n  incoming: \").concat(JSON.stringify(incoming).slice(0, 1000), \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\"));\n}","map":{"version":3,"sources":["C:/Users/Tapiwanashe Shoshore/Documents/Projects/spring.graphql.client/node_modules/@apollo/client/cache/inmemory/writeToStore.js"],"names":["__assign","invariant","InvariantError","equal","Trie","createFragmentMap","getFragmentFromSelection","getDefaultValues","getFragmentDefinitions","getOperationDefinition","getTypenameFromResult","makeReference","isField","resultKeyNameFromField","isReference","shouldInclude","cloneDeep","addTypenameToDocument","isNonEmptyArray","argumentsObjectFromField","makeProcessedFieldsMerger","fieldNameFromStoreName","storeValueIsStoreObject","isArray","canonicalStringify","normalizeReadFieldOptions","getContextFlavor","context","clientOnly","deferred","key","concat","flavored","flavors","get","set","StoreWriter","cache","reader","prototype","writeToStore","store","_a","_this","query","result","dataId","variables","overwrite","operationDefinition","merger","written","Object","create","merge","existing","incoming","varString","fragmentMap","incomingById","Map","ref","processSelectionSet","selectionSet","mergeTree","map","__DEV__","JSON","stringify","forEach","storeObject","fieldNodeSet","entityRef","size","applied","applyMerges","fieldsWithSelectionSets_1","field","name","value","hasSelectionSet_1","storeFieldName","hasMergeFunction_1","childTree","Boolean","info","keys","warnAboutDataLoss","retain","__ref","policies","typename","rootTypenamesById","__typename","readField","options","arguments","from","result_1","Set","flattenFields","resultFieldKey","add","getStoreFieldName","fieldName","getChildMergeTree","incomingValue","processFieldValue","childTypename","getMergeFunction","maybeRecycleChildMergeTree","added","getReadFunction","error","substring","_b","identify","id","keyObject","e","dataRef","sets","indexOf","push","isFresh","previous_1","mergeMergeTrees","mergeTreeIsEmpty","item","i","fieldMap","limitingTrie","flatten","inheritedContext","visitedNode","lookup","visited","selections","selection","directives","dir","args","if","fragment","fragmentMatches","getStorageArgs","e_1","i_1","changedFields_1","getValue_1","getFieldValue","String","eVal","iVal","aVal","pop","slice","runMergeFunction","getStorage","apply","emptyMergeTreePool","has","left","right","needToMergeMaps","merged","remainingRightKeys_1","leftTree","delete","tree","warnings","existingRef","incomingObj","getChild","objOrRef","child","every","parentType","typeDotName","childTypenames","includes","warn","length","join"],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport { createFragmentMap, getFragmentFromSelection, getDefaultValues, getFragmentDefinitions, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, } from \"../../utilities/index.js\";\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, isArray } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n;\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, flavored = (context.clientOnly === clientOnly &&\n            context.deferred === deferred) ? context : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred }));\n    }\n    return flavored;\n}\nvar StoreWriter = (function () {\n    function StoreWriter(cache, reader) {\n        this.cache = cache;\n        this.reader = reader;\n    }\n    StoreWriter.prototype.writeToStore = function (store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var context = {\n            store: store,\n            written: Object.create(null),\n            merge: function (existing, incoming) {\n                return merger.merge(existing, incoming);\n            },\n            variables: variables,\n            varString: canonicalStringify(variables),\n            fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n            overwrite: !!overwrite,\n            incomingById: new Map,\n            clientOnly: false,\n            deferred: false,\n            flavors: new Map,\n        };\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map },\n            context: context,\n        });\n        if (!isReference(ref)) {\n            throw __DEV__ ? new InvariantError(\"Could not identify object \".concat(JSON.stringify(result))) : new InvariantError(6);\n        }\n        context.incomingById.forEach(function (_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (isReference(applied)) {\n                    return;\n                }\n                storeObject = applied;\n            }\n            if (__DEV__ && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function (field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function (storeFieldName) {\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n                };\n                var hasMergeFunction_1 = function (storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function (storeFieldName) {\n                    if (hasSelectionSet_1(storeFieldName) &&\n                        !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        var incoming = Object.create(null);\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        var readField = function () {\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n            if (isReference(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {\n            var _a;\n            var resultFieldKey = resultKeyNameFromField(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables,\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, field.selectionSet\n                    ? getContextFlavor(context, false, false)\n                    : context, childTree);\n                var childTypename = void 0;\n                if (field.selectionSet &&\n                    (isReference(incomingValue) ||\n                        storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        field: field,\n                        typename: typename,\n                        merge: merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {},\n                    _a[storeFieldName] = incomingValue,\n                    _a));\n            }\n            else if (__DEV__ &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !addTypenameToDocument.added(field) &&\n                !policies.getReadFunction(typename, field.name.value)) {\n                __DEV__ && invariant.error(\"Missing field '\".concat(resultKeyNameFromField(field), \"' while writing result \").concat(JSON.stringify(result, null, 2)).substring(0, 1000));\n            }\n        });\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField,\n            }), id = _b[0], keyObject = _b[1];\n            dataId = dataId || id;\n            if (keyObject) {\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = makeReference(dataId);\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            return __DEV__ ? cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map(function (item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree,\n        });\n    };\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new Trie(false);\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function (selection) {\n                if (!shouldInclude(selection, context.variables))\n                    return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (!(clientOnly && deferred) &&\n                    isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach(function (dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = argumentsObjectFromField(dir, context.variables);\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                        }\n                    });\n                }\n                if (isField(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !isReference(incoming)) {\n            var e_1 = (!isArray(incoming) &&\n                (isReference(existing) || storeValueIsStoreObject(existing))) ? existing : void 0;\n            var i_1 = incoming;\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n            }\n            var changedFields_1;\n            var getValue_1 = function (from, name) {\n                return isArray(from)\n                    ? (typeof name === \"number\" ? from[name] : void 0)\n                    : context.store.getFieldValue(from, String(name));\n            };\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map;\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));\n                changedFields_1.forEach(function (value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map :\n        left.map.size ? left.map : right.map;\n    var merged = { info: info, map: map };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function (leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function (key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    if (isReference(existing))\n        return;\n    if (equal(existing, incoming))\n        return;\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    if (!isArray(existing) &&\n        !isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" &&\n                !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    __DEV__ && invariant.warn(\"Cache data may be lost when replacing the \".concat(fieldName, \" field of a \").concat(parentType, \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \").concat(childTypenames.length\n        ? \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \"\n        : \"\", \"define a custom merge function for the \").concat(typeDotName, \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \").concat(JSON.stringify(existing).slice(0, 1000), \"\\n  incoming: \").concat(JSON.stringify(incoming).slice(0, 1000), \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\"));\n}\n"]},"metadata":{},"sourceType":"module"}