{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\ngetStoreKeyName.setStringify(canonicalStringify);\n\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\n\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\n\nvar mergeTrueFn = function (existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\n\nvar mergeFalseFn = function (_, incoming) {\n  return incoming;\n};\n\nvar Policies = function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.toBeAdded = Object.create(null);\n    this.supertypeMap = new Map();\n    this.fuzzySubtypes = new Map();\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, partialContext) {\n    var _a;\n\n    var policies = this;\n    var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    var storeObject = partialContext && partialContext.storeObject || object;\n\n    var context = __assign(__assign({}, partialContext), {\n      typename: typename,\n      storeObject: storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        var options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables\n        });\n      }\n    });\n\n    var id;\n    var policy = typename && this.getTypePolicy(typename);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n\n    while (keyFn) {\n      var specifierOrId = keyFn(object, context);\n\n      if (isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var _a = typePolicies[typename],\n          queryType = _a.queryType,\n          mutationType = _a.mutationType,\n          subscriptionType = _a.subscriptionType,\n          incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n\n      if (queryType) _this.setRootTypename(\"Query\", typename);\n      if (mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(_this.toBeAdded, typename)) {\n        _this.toBeAdded[typename].push(incoming);\n      } else {\n        _this.toBeAdded[typename] = [incoming];\n      }\n    });\n  };\n\n  Policies.prototype.updateTypePolicy = function (typename, incoming) {\n    var _this = this;\n\n    var existing = this.getTypePolicy(typename);\n    var keyFields = incoming.keyFields,\n        fields = incoming.fields;\n\n    function setMerge(existing, merge) {\n      existing.merge = typeof merge === \"function\" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing.merge;\n    }\n\n    setMerge(existing, incoming.merge);\n    existing.keyFn = keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach(function (fieldName) {\n        var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n        var incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          var keyArgs = incoming.keyArgs,\n              read = incoming.read,\n              merge = incoming.merge;\n          existing.keyFn = keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      __DEV__ ? invariant(!old || old === which, \"Cannot change root \".concat(which, \" __typename more than once\")) : invariant(!old || old === which, 3);\n      if (old) delete this.rootIdsByTypename[old];\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      _this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(function (subtype) {\n        _this.getSupertypeSet(subtype, true).add(supertype);\n\n        var match = subtype.match(TypeOrFieldNameRegExp);\n\n        if (!match || match[0] !== subtype) {\n          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename) {\n    var _this = this;\n\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      var policy_1 = this.typePolicies[typename] = Object.create(null);\n      policy_1.fields = Object.create(null);\n      var supertypes = this.supertypeMap.get(typename);\n\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(function (supertype) {\n          var _a = _this.getTypePolicy(supertype),\n              fields = _a.fields,\n              rest = __rest(_a, [\"fields\"]);\n\n          Object.assign(policy_1, rest);\n          Object.assign(policy_1.fields, fields);\n        });\n      }\n    }\n\n    var inbox = this.toBeAdded[typename];\n\n    if (inbox && inbox.length) {\n      inbox.splice(0).forEach(function (policy) {\n        _this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    if (typename) {\n      var fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n    }\n  };\n\n  Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n    var supertypeSet = this.supertypeMap.get(subtype);\n\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n\n    return supertypeSet;\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      var workQueue_1 = [typenameSupertypeSet];\n\n      var maybeEnqueue_1 = function (subtype) {\n        var supertypeSet = _this.getSupertypeSet(subtype, false);\n\n        if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n          workQueue_1.push(supertypeSet);\n        }\n      };\n\n      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      var checkingFuzzySubtypes = false;\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var supertypeSet = workQueue_1[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              __DEV__ && invariant.warn(\"Inferring subtype \".concat(typename, \" of supertype \").concat(supertype));\n            }\n\n            typenameSupertypeSet.add(supertype);\n          }\n\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue_1);\n\n        if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n          this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n            var match = typename.match(regExp);\n\n            if (match && match[0] === typename) {\n              maybeEnqueue_1(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  };\n\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n        fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.getReadFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  };\n\n  Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n    var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n    var merge = policy && policy.merge;\n\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n\n    return merge;\n  };\n\n  Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n    var field = _a.field,\n        typename = _a.typename,\n        merge = _a.merge;\n\n    if (merge === mergeTrueFn) {\n      return makeMergeObjectsFunction(context.store)(existing, incoming);\n    }\n\n    if (merge === mergeFalseFn) {\n      return incoming;\n    }\n\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, {\n      typename: typename,\n      fieldName: field.name.value,\n      field: field,\n      variables: context.variables\n    }, context, storage || Object.create(null)));\n  };\n\n  return Policies;\n}();\n\nexport { Policies };\n\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n      toReference = _a.toReference,\n      canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function () {\n      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, context), context);\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store)\n  };\n}\n\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n  var fieldNameOrOptions = readFieldArgs[0],\n      from = readFieldArgs[1],\n      argc = readFieldArgs.length;\n  var options;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      from: argc > 1 ? from : objectOrReference\n    };\n  } else {\n    options = __assign({}, fieldNameOrOptions);\n\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    __DEV__ && invariant.warn(\"Undefined 'from' passed to readField with arguments \".concat(stringifyForDisplay(Array.from(readFieldArgs))));\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(store) {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw __DEV__ ? new InvariantError(\"Cannot automatically merge arrays\") : new InvariantError(4);\n    }\n\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      var eType = store.getFieldValue(existing, \"__typename\");\n      var iType = store.getFieldValue(incoming, \"__typename\");\n      var typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {\n        return __assign(__assign({}, existing), incoming);\n      }\n    }\n\n    return incoming;\n  };\n}","map":{"version":3,"sources":["C:/Users/Tapiwanashe Shoshore/Documents/Projects/spring.graphql.client/node_modules/@apollo/client/cache/inmemory/policies.js"],"names":["__assign","__rest","invariant","InvariantError","storeKeyNameFromField","argumentsObjectFromField","isReference","getStoreKeyName","isNonNullObject","stringifyForDisplay","hasOwn","fieldNameFromStoreName","storeValueIsStoreObject","selectionSetMatchesResult","TypeOrFieldNameRegExp","defaultDataIdFromObject","isArray","cacheSlot","canonicalStringify","keyArgsFnFromSpecifier","keyFieldsFnFromSpecifier","setStringify","argsFromFieldSpecifier","spec","args","field","variables","nullKeyFieldsFn","simpleKeyArgsFn","_args","context","fieldName","mergeTrueFn","existing","incoming","_a","mergeObjects","mergeFalseFn","_","Policies","config","typePolicies","Object","create","toBeAdded","supertypeMap","Map","fuzzySubtypes","rootIdsByTypename","rootTypenamesById","usingPossibleTypes","dataIdFromObject","cache","setRootTypename","possibleTypes","addPossibleTypes","addTypePolicies","prototype","identify","object","partialContext","policies","typename","storeObject","__typename","ROOT_QUERY","readField","options","normalizeReadFieldOptions","arguments","store","id","policy","getTypePolicy","keyFn","specifierOrId","String","keyObject","_this","keys","forEach","queryType","mutationType","subscriptionType","call","push","updateTypePolicy","keyFields","fields","setMerge","merge","getFieldPolicy","read","keyArgs","which","rootId","toUpperCase","old","__DEV__","concat","supertype","getSupertypeSet","subtype","add","match","set","RegExp","policy_1","supertypes","get","size","rest","assign","inbox","length","splice","createIfMissing","fieldPolicies","supertypeSet","Set","fragmentMatches","fragment","result","typeCondition","name","value","has","typenameSupertypeSet","workQueue_1","maybeEnqueue_1","indexOf","needToCheckFuzzySubtypes","checkingFuzzySubtypes","i","warn","selectionSet","regExp","fuzzyString","hasKeyArgs","getStoreFieldName","fieldSpec","storeFieldName","specifierOrString","objectOrReference","from","nameOrField","getFieldValue","readOptions","makeFieldFunctionOptions","getStorage","__ref","withValue","getReadFunction","getMergeFunction","parentTypename","childTypename","runMergeFunction","storage","makeMergeObjectsFunction","overwrite","toReference","canRead","readFieldArgs","fieldNameOrOptions","argc","Array","eType","iType","typesDiffer"],"mappings":"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","sourcesContent":["import { __assign, __rest } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray, } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\ngetStoreKeyName.setStringify(canonicalStringify);\nfunction argsFromFieldSpecifier(spec) {\n    return spec.args !== void 0 ? spec.args :\n        spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\nvar mergeTrueFn = function (existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) { return incoming; };\nvar Policies = (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.toBeAdded = Object.create(null);\n        this.supertypeMap = new Map();\n        this.fuzzySubtypes = new Map();\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, partialContext) {\n        var _a;\n        var policies = this;\n        var typename = partialContext && (partialContext.typename ||\n            ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\"ROOT_QUERY\"];\n        }\n        var storeObject = partialContext && partialContext.storeObject || object;\n        var context = __assign(__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: partialContext && partialContext.readField || function () {\n                var options = normalizeReadFieldOptions(arguments, storeObject);\n                return policies.readField(options, {\n                    store: policies.cache[\"data\"],\n                    variables: options.variables,\n                });\n            } });\n        var id;\n        var policy = typename && this.getTypePolicy(typename);\n        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(object, context);\n            if (isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n            if (queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            if (hasOwn.call(_this.toBeAdded, typename)) {\n                _this.toBeAdded[typename].push(incoming);\n            }\n            else {\n                _this.toBeAdded[typename] = [incoming];\n            }\n        });\n    };\n    Policies.prototype.updateTypePolicy = function (typename, incoming) {\n        var _this = this;\n        var existing = this.getTypePolicy(typename);\n        var keyFields = incoming.keyFields, fields = incoming.fields;\n        function setMerge(existing, merge) {\n            existing.merge =\n                typeof merge === \"function\" ? merge :\n                    merge === true ? mergeTrueFn :\n                        merge === false ? mergeFalseFn :\n                            existing.merge;\n        }\n        setMerge(existing, incoming.merge);\n        existing.keyFn =\n            keyFields === false ? nullKeyFieldsFn :\n                isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n                    typeof keyFields === \"function\" ? keyFields :\n                        existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach(function (fieldName) {\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\n                var incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                }\n                else {\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                    existing.keyFn =\n                        keyArgs === false ? simpleKeyArgsFn :\n                            isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n                                typeof keyArgs === \"function\" ? keyArgs :\n                                    existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            __DEV__ ? invariant(!old || old === which, \"Cannot change root \".concat(which, \" __typename more than once\")) : invariant(!old || old === which, 3);\n            if (old)\n                delete this.rootIdsByTypename[old];\n            this.rootIdsByTypename[typename] = rootId;\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            _this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach(function (subtype) {\n                _this.getSupertypeSet(subtype, true).add(supertype);\n                var match = subtype.match(TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename) {\n        var _this = this;\n        if (!hasOwn.call(this.typePolicies, typename)) {\n            var policy_1 = this.typePolicies[typename] = Object.create(null);\n            policy_1.fields = Object.create(null);\n            var supertypes = this.supertypeMap.get(typename);\n            if (supertypes && supertypes.size) {\n                supertypes.forEach(function (supertype) {\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [\"fields\"]);\n                    Object.assign(policy_1, rest);\n                    Object.assign(policy_1.fields, fields);\n                });\n            }\n        }\n        var inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            inbox.splice(0).forEach(function (policy) {\n                _this.updateTypePolicy(typename, policy);\n            });\n        }\n        return this.typePolicies[typename];\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        if (typename) {\n            var fieldPolicies = this.getTypePolicy(typename).fields;\n            return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n        }\n    };\n    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n        var supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, supertypeSet = new Set());\n        }\n        return supertypeSet;\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes &&\n            this.supertypeMap.has(supertype)) {\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            var workQueue_1 = [typenameSupertypeSet];\n            var maybeEnqueue_1 = function (subtype) {\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\n                if (supertypeSet &&\n                    supertypeSet.size &&\n                    workQueue_1.indexOf(supertypeSet) < 0) {\n                    workQueue_1.push(supertypeSet);\n                }\n            };\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            var checkingFuzzySubtypes = false;\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var supertypeSet = workQueue_1[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            __DEV__ && invariant.warn(\"Inferring subtype \".concat(typename, \" of supertype \").concat(supertype));\n                        }\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue_1);\n                if (needToCheckFuzzySubtypes &&\n                    i === workQueue_1.length - 1 &&\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n                        var match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue_1(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.keyFn);\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = fieldSpec.field\n                ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        return fieldName === fieldNameFromStoreName(storeFieldName)\n            ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference)\n                ? objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n        }\n        return existing;\n    };\n    Policies.prototype.getReadFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return policy && policy.read;\n    };\n    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n        var merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    };\n    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\n        if (merge === mergeTrueFn) {\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            return incoming;\n        }\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename: typename, fieldName: field.name.value, field: field, variables: context.variables }, context, storage || Object.create(null)));\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function () {\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, context), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store),\n    };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n    var options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            from: argc > 1 ? from : objectOrReference,\n        };\n    }\n    else {\n        options = __assign({}, fieldNameOrOptions);\n        if (!hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (__DEV__ && options.from === void 0) {\n        __DEV__ && invariant.warn(\"Undefined 'from' passed to readField with arguments \".concat(stringifyForDisplay(Array.from(readFieldArgs))));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if (isArray(existing) || isArray(incoming)) {\n            throw __DEV__ ? new InvariantError(\"Cannot automatically merge arrays\") : new InvariantError(4);\n        }\n        if (isNonNullObject(existing) &&\n            isNonNullObject(incoming)) {\n            var eType = store.getFieldValue(existing, \"__typename\");\n            var iType = store.getFieldValue(incoming, \"__typename\");\n            var typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if (isReference(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                isReference(incoming)) {\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                return __assign(__assign({}, existing), incoming);\n            }\n        }\n        return incoming;\n    };\n}\n"]},"metadata":{},"sourceType":"module"}